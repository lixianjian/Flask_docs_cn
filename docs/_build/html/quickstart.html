
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>快速入门 &#8212; Flask 0.12.2 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.12.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/flask-favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="教程" href="tutorial/index.html" />
    <link rel="prev" title="安装" href="installation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
    <link rel="apple-touch-icon" href="_static/touch-icon.png" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="quickstart">
<span id="id1"></span><h1>快速入门<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h1>
<p>迫切希望上手？本文提供了一个很好的 Flask 介绍。假设你已经安装 Flask，
如果还没有安装话，请浏览下 <a class="reference internal" href="installation.html#installation"><span class="std std-ref">安装</span></a> 。</p>
<div class="section" id="id2">
<h2>一个最小的应用<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>一个最小的应用看起来像这样:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello World!&#39;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>把它保存成 <cite>hello.py</cite> (或者类似的文件)，然后用 Python 解释器运行它。确保你的应用不叫做 <cite>flask.py</cite>，
因为这会与 Flask 本身冲突。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python hello.py
 * Running on http://127.0.0.1:5000/
</pre></div>
</div>
<p>现在浏览 <a class="reference external" href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>，你会看到你的 <cite>Hello World</cite> 问候。</p>
<p>那么这段代码做了什么？</p>
<ol class="arabic simple">
<li>首先我们导入了类 <a class="reference internal" href="api.html#flask.Flask" title="flask.Flask"><code class="xref py py-class docutils literal"><span class="pre">Flask</span></code></a> 。这个类的实例化将会是我们的 WSGI 应用。第一个参数是应用模块的名称。
如果你使用的是单一的模块（就如本例），第一个参数应该使用 <cite>__name__</cite>。因为取决于如果它以单独应用启动或作为模块导入，
名称将会不同 （ <code class="docutils literal"><span class="pre">'__main__'</span></code> 对应于实际导入的名称）。获取更多的信息，请阅读 <a class="reference internal" href="api.html#flask.Flask" title="flask.Flask"><code class="xref py py-class docutils literal"><span class="pre">Flask</span></code></a> 的文档。</li>
<li>接着，我们创建一个该类的实例。我们传递给它模块或包的名称。这样 Flask 才会知道去哪里寻找模板、静态文件等等。</li>
<li>我们使用装饰器 <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal"><span class="pre">route()</span></code></a> 告诉 Flask 哪个 URL 才能触发我们的函数。</li>
<li>定义一个函数，该函数名也是用来给特定函数生成 URLs，并且返回我们想要显示在用户浏览器上的信息。</li>
<li>最后我们用函数 <a class="reference internal" href="api.html#flask.Flask.run" title="flask.Flask.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> 启动本地服务器来运行我们的应用。<code class="docutils literal"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__':</span></code>
确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。</li>
</ol>
<p>请按 control-C 来停止服务器。</p>
<div class="admonition- admonition" id="public-server">
<p class="first admonition-title">外部可见服务器</p>
<p>当你运行服务器，你会注意到它只能从你自己的计算机上访问，网络中其它任何的地方都不能访问。
这是因为默认情况下，调试模式，应用中的一个用户可以执行你计算机上的任意 Python 代码。</p>
<p>如果你关闭 <cite>debug</cite> 或者信任你所在网络上的用户，你可以让你的服务器对外可用，只要简单地改变方法
<a class="reference internal" href="api.html#flask.Flask.run" title="flask.Flask.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> 的调用像如下这样:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">这让你的操作系统去监听所有公开的 IP。</p>
</div>
</div>
<div class="section" id="debug-mode">
<span id="id3"></span><h2>调试模式<a class="headerlink" href="#debug-mode" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="api.html#flask.Flask.run" title="flask.Flask.run"><code class="xref py py-meth docutils literal"><span class="pre">run()</span></code></a> 方法是十分适用于启动一个本地开发服务器，但是你需要在修改代码后手动重启服务器。
这样做并不好，Flask 能做得更好。如果启用了调试支持，在代码修改的时候服务器能够自动加载，
并且如果发生错误，它会提供一个有用的调试器。</p>
<p>有两种方式开启调式模式。一种是在应用对象上设置标志位:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>或者作为 run 的一个参数传入:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>两种方法效果是一样的。</p>
<div class="admonition-attention admonition">
<p class="first admonition-title">Attention</p>
<p class="last">尽管交互式调试器不能在分叉( forking )环境上工作(这使得它几乎不可能在生产服务器上使用)，
它依然允许执行任意代码。这使它成为一个巨大的安全风险，因此它 <strong>绝对不能用于生成环境</strong>。</p>
</div>
<p>运行中的调试器的截图:</p>
<img alt="screenshot of debugger in action" class="screenshot align-center" src="_images/debugger.png" />
<p>是不是还有其它的调试器？请查看 <a class="reference internal" href="errorhandling.html#working-with-debuggers"><span class="std std-ref">使用调试器</span></a>。</p>
</div>
<div class="section" id="id4">
<h2>路由<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>现代 Web 应用程序有优雅的 URLs。这能够帮助人们记住 URLs，这点在面向使用慢网络连接的移动设备的应用上有用。
如果用户不必通过点击首页而直接访问想要的页面，很可能他们会喜欢这个页面而且下次再次访问。</p>
<p>正如上面所说， <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal"><span class="pre">route()</span></code></a> 装饰器是用于把一个函数绑定到一个 URL 上。这有些基本的例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Index Page&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello World&#39;</span>
</pre></div>
</div>
<p>但是不仅如此！你可以动态地构造 URL 的特定部分，也可以在一个函数上附加多个规则。</p>
<div class="section" id="id5">
<h3>变量规则<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>为了给 URL 增加变量的部分，你需要把一些特定的字段标记成 <code class="docutils literal"><span class="pre">&lt;variable_name&gt;</span></code>。这些特定的字段将作为参数传入到你的函数中。当然也可以指定一个可选的转换器通过规则 <code class="docutils literal"><span class="pre">&lt;converter:variable_name&gt;</span></code>。
这里有一些不错的例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user_profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="c1"># show the user profile for that user</span>
    <span class="k">return</span> <span class="s1">&#39;User </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">username</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/post/&lt;int:post_id&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="c1"># show the post with the given id, the id is an integer</span>
    <span class="k">return</span> <span class="s1">&#39;Post </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">post_id</span>
</pre></div>
</div>
<p>存在如下转换器:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>int</cite></td>
<td>接受整数</td>
</tr>
<tr class="row-even"><td><cite>float</cite></td>
<td>同 <cite>int</cite> 一样，但是接受浮点数</td>
</tr>
<tr class="row-odd"><td><cite>path</cite></td>
<td>和默认的相似，但也接受斜线</td>
</tr>
</tbody>
</table>
<div class="admonition-urls admonition">
<p class="first admonition-title">唯一 URLs / 重定向行为</p>
<p>Flask 的 URL 规则是基于 Werkzeug 的 routing 模块。
该模块背后的想法是基于 Apache 和早期的 HTTP 服务器定下先例确保优雅和唯一的 URL。</p>
<p>以这两个规则为例:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/projects/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">projects</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;The project page&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/about&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;The about page&#39;</span>
</pre></div>
</div>
<p>虽然它们看起来确实相似，但它们结尾斜线的使用在 URL <em>定义</em> 中不同。
第一种情况中，规范的 URL 指向 projects 尾端有一个斜线。
这种感觉很像在文件系统中的文件夹。访问一个结尾不带斜线的 URL 会被 Flask 重定向到带斜线的规范URL去。</p>
<p>然而，第二种情况的 URL 结尾不带斜线，类似 UNIX-like 系统下的文件的路径名。
访问结尾带斜线的 URL 会产生一个 404 “Not Found” 错误。</p>
<p class="last">当用户访问页面时忘记结尾斜线时，这个行为允许关联的 URL 继续工作，
并且与 Apache 和其它的服务器的行为一致。另外，URL 会保持唯一，有助于避免搜索引擎索引同一个页面两次。</p>
</div>
</div>
<div class="section" id="url">
<span id="url-building"></span><h3>构建 URL<a class="headerlink" href="#url" title="Permalink to this headline">¶</a></h3>
<p>如果它可以匹配 URL，那么 Flask 能够生成它们吗？当然 Flask 能够做到。你可以使用函数
<a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal"><span class="pre">url_for()</span></code></a> 来针对一个特定的函数构建一个 URL。它能够接受函数名作为第一参数，以及一些关键字参数，
每一个关键字参数对应于 URL 规则的变量部分。未知变量部分被插入到 URL 中作为查询参数。这里有些例子：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">url_for</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">index</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">login</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">():</span>
<span class="gp">... </span> <span class="nb">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="gp">... </span> <span class="nb">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">)</span>
<span class="gp">... </span> <span class="nb">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="gp">... </span> <span class="nb">print</span> <span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">&#39;John Doe&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">/</span>
<span class="go">/login</span>
<span class="go">/login?next=/</span>
<span class="go">/user/John%20Doe</span>
</pre></div>
</div>
<p>(这里也使用了 <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></code></a> 方法，下面会给出解释。这个方法告诉 Flask 表现得像是在处理一个请求，即使我们正在通过 Python 的 shell 交互。
请看下面的解释。 <a class="reference internal" href="#context-locals"><span class="std std-ref">局部上下文</span></a>)。</p>
<p>为什么你愿意构建 URLs 而不是在模版中硬编码？这里有三个好的理由：</p>
<ol class="arabic simple">
<li>反向构建通常比硬编码更具备描述性。更重要的是，它允许你一次性修改 URL，
而不是到处找 URL 修改。</li>
<li>构建 URL 能够显式地处理特殊字符和 Unicode 转义，因此你不必去处理这些。</li>
<li>如果你的应用不在 URL 根目录下(比如，在
<code class="docutils literal"><span class="pre">/myapplication</span></code> 而不在 <code class="docutils literal"><span class="pre">/</span></code>)， <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal"><span class="pre">url_for()</span></code></a> 将会适当地替你处理好。</li>
</ol>
</div>
<div class="section" id="http">
<h3>HTTP方法<a class="headerlink" href="#http" title="Permalink to this headline">¶</a></h3>
<p>HTTP (也就说 web 应用协议)有不同的方法来访问 URLs。默认情况下，路由只会响应 <cite>GET</cite> 请求，
但是能够通过给 <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal"><span class="pre">route()</span></code></a> 装饰器提供 <cite>methods</cite> 参数来改变。这里是些例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">do_the_login</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">show_the_login_form</span><span class="p">()</span>
</pre></div>
</div>
<p>如果使用 <cite>GET</cite> 方法，<cite>HEAD</cite> 方法将会自动添加进来。你不必处理它们。也能确保 <cite>HEAD</cite> 请求
会按照 <a class="reference external" href="http://www.ietf.org/rfc/rfc2068.txt">HTTP RFC</a> (文档在 HTTP 协议里面描述) 要求来处理， 因此你完全可以忽略这部分 HTTP 规范。
同样地，自从 Flask 0.6 后，<cite>OPTIONS</cite> 也能自动为你处理。</p>
<p>也许你并不清楚 HTTP 方法是什么？别担心，这里有一个 HTTP 方法的快速入门以及为什么它们重要：</p>
<p>HTTP 方法（通常也称为“谓词”）告诉服务器客户端想要对请求的页面 <em>做</em> 什么。下面这些方法是比较常见的：</p>
<dl class="docutils">
<dt><cite>GET</cite></dt>
<dd>浏览器通知服务器只 <em>获取</em> 页面上的信息并且发送回来。这可能是最常用的方法。</dd>
<dt><cite>HEAD</cite></dt>
<dd>浏览器告诉服务器获取信息，但是只对 <em>头信息</em> 感兴趣，不需要整个页面的内容。
应用应该处理起来像接收到一个 <cite>GET</cite> 请求但是不传递实际内容。在 Flask 中你完全不需要处理它，
底层的 Werkzeug 库会为你处理的。</dd>
<dt><cite>POST</cite></dt>
<dd>浏览器通知服务器它要在 URL 上 <em>提交</em> 一些信息，服务器必须保证数据被存储且只存储一次。
这是 HTML 表单通常发送数据到服务器的方法。</dd>
<dt><cite>PUT</cite></dt>
<dd>同 <cite>POST</cite> 类似，但是服务器可能触发了多次存储过程，多次覆盖掉旧值。现在你就会问这有什么用，
有许多理由需要如此去做。考虑下在传输过程中连接丢失：在这种情况下浏览器 和服务器之间的系统可能安全地第二次接收请求，而不破坏其它东西。对于 <cite>POST</cite> 是不可能实现的，因为
它只会被触发一次。</dd>
<dt><cite>DELETE</cite></dt>
<dd>移除给定位置的信息。</dd>
<dt><cite>OPTIONS</cite></dt>
<dd>给客户端提供一个快速的途径来指出这个 URL 支持哪些 HTTP 方法。从 Flask 0.6 开始，自动实现了它。</dd>
</dl>
<p>现在比较有兴趣的是在 HTML4 和 XHTML1，表单只能以 <cite>GET</cite> 和 <cite>POST</cite> 方法来提交到服务器。在 JavaScript 和以后的 HTML 标准中也能使用其它的方法。同时，HTTP 最近变得十分流行，浏览器不再是唯一使用 HTTP 的客户端。比如，许多版本控制系统使用 HTTP。</p>
</div>
</div>
<div class="section" id="id6">
<h2>静态文件<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>动态的 web 应用同样需要静态文件。CSS 和 JavaScript 文件通常来源于此。理想情况下，
你的 web 服务器已经配置好为它们服务，然而在开发过程中 Flask 能够做到。
只要在你的包中或模块旁边创建一个名为 <cite>static</cite> 的文件夹，在应用中使用 <cite>/static</cite> 即可访问。</p>
<p>给静态文件生成 URL ，使用特殊的 <code class="docutils literal"><span class="pre">'static'</span></code> 端点名:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;style.css&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>这个文件应该存储在文件系统上称为 <code class="docutils literal"><span class="pre">static/style.css</span></code>。</p>
</div>
<div class="section" id="id7">
<h2>渲染模板<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>在 Python 中生成 HTML 并不好玩，实际上是相当繁琐的，因为你必须自行做好 HTML 转义以保持应用程序的安全。
由于这个原因，Flask 自动为你配置好 <a class="reference external" href="http://jinja.pocoo.org/2/">Jinja2</a> 模版。</p>
<p>你可以使用方法 <a class="reference internal" href="api.html#flask.render_template" title="flask.render_template"><code class="xref py py-func docutils literal"><span class="pre">render_template()</span></code></a> 来渲染模版。所有你需要做的就是提供模版的名称以及你想要作为关键字参数传入模板的变量。这里有个渲染模版的简单例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">render_template</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello/&#39;</span><span class="p">)</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;hello.html&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>Flask 将会在 <cite>templates</cite> 文件夹中寻找模版。因此如果你的应用是个模块，这个文件夹在模块的旁边，如果它是一个包，那么这个文件夹在你的包里面:</p>
<p><strong>Case 1</strong>: 一个模块:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">application</span><span class="o">.</span><span class="n">py</span>
<span class="o">/</span><span class="n">templates</span>
    <span class="o">/</span><span class="n">hello</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p><strong>Case 2</strong>: 一个包:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">application</span>
    <span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="o">/</span><span class="n">templates</span>
        <span class="o">/</span><span class="n">hello</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p>对于模板，你可以使用 Jinja2 模板的全部功能。详细信息查看官方的 <a class="reference external" href="http://jinja.pocoo.org/2/documentation/templates">Jinja2 Template Documentation</a> 。</p>
<p>这里是一个模版的例子：</p>
<div class="highlight-html+jinja"><div class="highlight"><pre><span></span><span class="cp">&lt;!doctype html&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Hello from Flask<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">if</span> <span class="nv">name</span> <span class="cp">%}</span>
  <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello <span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span>
  <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello World!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>在模版中你也可以使用 <a class="reference internal" href="api.html#flask.request" title="flask.request"><code class="xref py py-class docutils literal"><span class="pre">request</span></code></a>,
<a class="reference internal" href="api.html#flask.session" title="flask.session"><code class="xref py py-class docutils literal"><span class="pre">session</span></code></a> 和 <a class="reference internal" href="api.html#flask.g" title="flask.g"><code class="xref py py-class docutils literal"><span class="pre">g</span></code></a> <a class="footnote-reference" href="#id9" id="id8">[1]</a> 对象，也能使用函数 <a class="reference internal" href="api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><code class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></code></a> 。</p>
<p>模版继承是十分有用的。如果想要知道模版继承如何工作的话，请阅读文档
<a class="reference internal" href="patterns/templateinheritance.html#template-inheritance"><span class="std std-ref">模板继承</span></a> 。基本的模版继承使得某些特定元素（如标题，导航和页脚）在每一页成为可能。</p>
<p>自动转义是开启的，因此如果 <cite>name</cite> 包含 HTML，它将会自动转义。如果你信任一个变量，并且你知道它是安全的
（例如一个模块把 wiki 标记转换到 HTML ），你可以用 <a class="reference external" href="http://jinja.pocoo.org/docs/api/#jinja2.Markup" title="(in Jinja2 v2.11)"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> 类或 <code class="docutils literal"><span class="pre">|safe</span></code> 过滤器在模板中标记它是安全的。
在 Jinja 2 文档中，你会见到更多例子。</p>
<p>这是一个 <a class="reference external" href="http://jinja.pocoo.org/docs/api/#jinja2.Markup" title="(in Jinja2 v2.11)"><code class="xref py py-class docutils literal"><span class="pre">Markup</span></code></a> 类如何工作的基本介绍：</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Markup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s1">&#39;&lt;strong&gt;Hello </span><span class="si">%s</span><span class="s1">!&lt;/strong&gt;&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="s1">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span>
<span class="go">Markup(u&#39;&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span><span class="p">)</span>
<span class="go">Markup(u&#39;&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s1">&#39;&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u&#39;Marked up \xbb HTML&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.5: </span>自动转义不再在所有模版中启用。模板中下列后缀的文件会触发自动转义：<code class="docutils literal"><span class="pre">.html</span></code>, <code class="docutils literal"><span class="pre">.htm</span></code>,
<code class="docutils literal"><span class="pre">.xml</span></code>, <code class="docutils literal"><span class="pre">.xhtml</span></code>。从字符串加载的模板会禁用自动转义。</p>
</div>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[1]</a></td><td>不知道 <a class="reference internal" href="api.html#flask.g" title="flask.g"><code class="xref py py-class docutils literal"><span class="pre">g</span></code></a> 对象是什么？它是可以按你的需求存储信息的东西，更多的信息查看 <a class="reference internal" href="api.html#flask.g" title="flask.g"><code class="xref py py-class docutils literal"><span class="pre">g</span></code></a> 文档以及
<a class="reference internal" href="patterns/sqlite3.html#sqlite3"><span class="std std-ref">在 Flask 中使用 SQLite 3</span></a>。</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id10">
<h2>接收请求数据<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>对于 web 应用来说，对客户端发送给服务器的数据做出反应至关重要。在 Flask 中由全局对象 <a class="reference internal" href="api.html#flask.request" title="flask.request"><code class="xref py py-class docutils literal"><span class="pre">request</span></code></a>
来提供这些信息。如果你有一定的 Python 经验，你会好奇这个对象怎么可能是全局的，并且 Flask 是怎么还能保证线程安全。
答案是上下文作用域:</p>
<div class="section" id="context-locals">
<span id="id11"></span><h3>局部上下文<a class="headerlink" href="#context-locals" title="Permalink to this headline">¶</a></h3>
<div class="admonition- admonition">
<p class="first admonition-title">内幕消息</p>
<p class="last">如果你想要了解它是如何工作以及如何用它实现测试，请阅读本节，否则请跳过本节。</p>
</div>
<p>Flask 中的某些对象是全局对象，但不是通常的类型。这些对象实际上是给定上下文的局部对象的代理。
虽然很拗口，但实际上很容易理解。</p>
<p>想象下线程处理的上下文。一个请求传入，web 服务器决定产生一个新线程(或者其它东西，
底层对象比线程更有能力处理并发系统)。当 Flask 开始它内部请求处理时，它认定当前线程是活动的上下文并绑定当前的应用和 WSGI 环境到那 个上下文（线程）。它以一种智能的方法来实现，以致一个应用可以调用另一个应用而不会中断。</p>
<p>所以这对你意味着什么了？如果你是做一些类似单元测试的事情否则基本你可以完全忽略这种情况。
你会发现依赖于请求对象的代码会突然中断，因为没有请求对象。解决方案就是自己创建一个请求并把它跟上下文绑定。
针对单元测试最早的解决方案是使用 <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal"><span class="pre">test_request_context()</span></code></a> 上下文管理器。结合 <cite>with</cite> 声明，它将绑定一个测试请求来进行交互。这里是一个例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">):</span>
    <span class="c1"># now you can do something with the request until the</span>
    <span class="c1"># end of the with block, such as basic assertions:</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;/hello&#39;</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span>
</pre></div>
</div>
<p>另一个可能性就是传入整个 WSGI 环境到 <a class="reference internal" href="api.html#flask.Flask.request_context" title="flask.Flask.request_context"><code class="xref py py-meth docutils literal"><span class="pre">request_context()</span></code></a> 方法:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>请求对象<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>请求对象在 API 章节中描述，这里我们不再详细涉及(请看 <a class="reference internal" href="api.html#flask.request" title="flask.request"><code class="xref py py-class docutils literal"><span class="pre">request</span></code></a>)。这里对一些最常见的操作进行概述。
首先你需要从 <cite>flask</cite> 模块中导入它:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>
</pre></div>
</div>
<p>当前请求的方法可以用 <code class="xref py py-attr docutils literal"><span class="pre">method</span></code> 属性来访问。你可以用 <code class="xref py py-attr docutils literal"><span class="pre">form</span></code> 属性来访问表单数据
(数据在 <cite>POST</cite> 或者 <cite>PUT</cite> 中传输)。这里是上面提及到两种属性的完整的例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;GET&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valid_login</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">],</span>
                       <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;password&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">log_the_user_in</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s1">&#39;Invalid username/password&#39;</span>
    <span class="c1"># the code below this is executed if the request method</span>
    <span class="c1"># was GET or the credentials were invalid</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;login.html&#39;</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>如果在 <cite>form</cite> 属性中不存在上述键值会发生些什么？在这种情况下会触发一个特别的 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.6)"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a>。
你可以像捕获标准的 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.6)"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> 来捕获它，如果你不这样去做，会显示一个 HTTP 400 Bad Request 错误页面。
所以很多情况下你不需要处理这个问题。</p>
<p>你可以用 <code class="xref py py-attr docutils literal"><span class="pre">args</span></code> 属性来接收在 URL ( <code class="docutils literal"><span class="pre">?key=value</span></code> ) 中提交的参数:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">searchword</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>我们推荐使用 <cite>get</cite> 来访问 URL 参数或捕获 <cite>KeyError</cite> ，因为用户可能会修改 URL，
向他们显示一个 400 bad request 页面不是用户友好的。</p>
<p>想获取请求对象的完整的方法和属性清单，请参阅 <a class="reference internal" href="api.html#flask.request" title="flask.request"><code class="xref py py-class docutils literal"><span class="pre">request</span></code></a> 的文档。</p>
</div>
<div class="section" id="id13">
<h3>文件上传<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>你能够很容易地用 Flask 处理文件上传。只要确保在你的 HTML 表单中不要忘记设置属性 <code class="docutils literal"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></code>，
否则浏览器将不传送文件。</p>
<p>上传的文件是存储在内存或者文件系统上一个临时位置。你可以通过请求对象中 <code class="xref py py-attr docutils literal"><span class="pre">files</span></code> 属性访问这些文件。
每个上传的文件都会存储在这个属性字典里。它表现得像一个标准的 Python <code class="xref py py-class docutils literal"><span class="pre">file</span></code> 对象，但是它同样具有
<a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.save" title="(in Werkzeug v0.14-dev)"><code class="xref py py-meth docutils literal"><span class="pre">save()</span></code></a> 方法，该方法允许你存储文件在服务器的文件系统上。
这儿是一个简单的例子展示如何工作的:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/var/www/uploads/uploaded_file.txt&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果你想要知道在上传到你的应用之前在客户端的文件名称，你可以访问 <a class="reference external" href="http://werkzeug.pocoo.org/docs/datastructures/#werkzeug.datastructures.FileStorage.filename" title="(in Werkzeug v0.14-dev)"><code class="xref py py-attr docutils literal"><span class="pre">filename</span></code></a>
属性。但请记住永远不要信任这个值，因为这个值可以伪造。如果你想要使用客户端的文件名来在服务器上存储文件，
把它传递到 Werkzeug 提供给你的 <a class="reference external" href="http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename" title="(in Werkzeug v0.14-dev)"><code class="xref py py-func docutils literal"><span class="pre">secure_filename()</span></code></a> 函数:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">secure_filename</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/var/www/uploads/&#39;</span> <span class="o">+</span> <span class="n">secure_filename</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>一些更好的例子，请查看 <a class="reference internal" href="patterns/fileuploads.html#uploading-files"><span class="std std-ref">上传文件</span></a> 。</p>
</div>
<div class="section" id="cookies">
<h3>Cookies<a class="headerlink" href="#cookies" title="Permalink to this headline">¶</a></h3>
<p>你可以用 <a class="reference internal" href="api.html#flask.Request.cookies" title="flask.Request.cookies"><code class="xref py py-attr docutils literal"><span class="pre">cookies</span></code></a> 属性来访问 cookies。你能够用响应对象的 <a class="reference internal" href="api.html#flask.Response.set_cookie" title="flask.Response.set_cookie"><code class="xref py py-attr docutils literal"><span class="pre">set_cookie</span></code></a>
来设置 cookies。请求对象中的 <a class="reference internal" href="api.html#flask.Request.cookies" title="flask.Request.cookies"><code class="xref py py-attr docutils literal"><span class="pre">cookies</span></code></a> 属性是一个客户端发送所有的 cookies 的字典。
如果你要使用会话(sessions)，请不要直接使用 cookies 相反用 Flask 中的 <a class="reference internal" href="#sessions"><span class="std std-ref">会话</span></a>，Flask 已经在 cookies 上增加了一些安全细节。</p>
<p>读取 cookies:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">)</span>
    <span class="c1"># use cookies.get(key) instead of cookies[key] to not get a</span>
    <span class="c1"># KeyError if the cookie is missing.</span>
</pre></div>
</div>
<p>存储 cookies:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">make_response</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;the username&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
<p>注意 cookies 是在响应对象中被设置。由于通常只是从视图函数返回字符串， Flask 会将其转换为响应对象。
如果你要显式地这么做，你可以使用 <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-meth docutils literal"><span class="pre">make_response()</span></code></a> 函数接着修改它。</p>
<p>有时候你可能要在响应对象不存在的地方设置 cookie。利用 <a class="reference internal" href="patterns/deferredcallbacks.html#deferred-callbacks"><span class="std std-ref">延迟请求回调</span></a> 模式使得这种情况成为可能。</p>
<p>为此也可以参阅 <a class="reference internal" href="#about-responses"><span class="std std-ref">关于响应</span></a>。</p>
</div>
</div>
<div class="section" id="id14">
<h2>重定向和错误<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>你能够用 <a class="reference internal" href="api.html#flask.redirect" title="flask.redirect"><code class="xref py py-func docutils literal"><span class="pre">redirect()</span></code></a> 函数重定向用户到其它地方。能够用 <a class="reference internal" href="api.html#flask.abort" title="flask.abort"><code class="xref py py-func docutils literal"><span class="pre">abort()</span></code></a> 函数提前中断一个请求并带有一个错误代码。
这里是一个它们如何工作的例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">abort</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">))</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
    <span class="n">this_is_never_executed</span><span class="p">()</span>
</pre></div>
</div>
<p>这是一个相当无意义的例子因为用户会从主页重定向到一个不能访问的页面（ 401意味着禁止访问），
但是它说明了重定向如何工作。</p>
<p>默认情况下，每个错误代码会显示一个黑白错误页面。如果你想定制错误页面，可以使用 <a class="reference internal" href="api.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code class="xref py py-meth docutils literal"><span class="pre">errorhandler()</span></code></a> 装饰器:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">render_template</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;page_not_found.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>注意到 <code class="docutils literal"><span class="pre">404</span></code> 是在 <a class="reference internal" href="api.html#flask.render_template" title="flask.render_template"><code class="xref py py-func docutils literal"><span class="pre">render_template()</span></code></a> 调用之后。告诉 Flask 该页的错误代码应是 404 ，
即没有找到。默认的 200 被假定为：一切正常。</p>
</div>
<div class="section" id="about-responses">
<span id="id15"></span><h2>关于响应<a class="headerlink" href="#about-responses" title="Permalink to this headline">¶</a></h2>
<p>一个视图函数的返回值会被自动转换为一个响应对象。如果返回值是一个字符串，它被转换成一个响应主体是该字符串，错误代码为 <code class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></code> ，媒体类型为 <code class="docutils literal"><span class="pre">text/html</span></code> 的响应对象。
Flask 把返回值转换成响应对象的逻辑如下：</p>
<ol class="arabic simple">
<li>如果返回的是一个合法的响应对象，它会被从视图直接返回。</li>
<li>如果返回的是一个字符串，响应对象会用字符串数据和默认参数创建。</li>
<li>如果返回的是一个元组而且元组中元素能够提供额外的信息。这样的元组必须是 <code class="docutils literal"><span class="pre">(response,</span> <span class="pre">status,</span>
<span class="pre">headers)</span></code> 形式且至少含有一个元素。 <cite>status</cite> 值将会覆盖状态代码，<cite>headers</cite> 可以是一个列表或额外的消息头值字典。</li>
<li>如果上述条件均不满足，Flask 会假设返回值是一个合法的 WSGI 应用程序，并转换为一个请求对象。</li>
</ol>
<p>如果你想要获取在视图中得到的响应对象，你可以用函数 <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-func docutils literal"><span class="pre">make_response()</span></code></a> 。</p>
<p>想象你有这样一个视图:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p>你只需要用 <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-func docutils literal"><span class="pre">make_response()</span></code></a> 封装返回表达式，获取结果对象并修改，然后返回它：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="nd">@app.errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span><span class="p">)</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;X-Something&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;A value&#39;</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
</div>
<div class="section" id="sessions">
<span id="id16"></span><h2>会话<a class="headerlink" href="#sessions" title="Permalink to this headline">¶</a></h2>
<p>除了请求对象，还有第二个称为 <a class="reference internal" href="api.html#flask.session" title="flask.session"><code class="xref py py-class docutils literal"><span class="pre">session</span></code></a> 对象允许你在不同请求间存储特定用户的信息。
这是在 cookies 的基础上实现的，并且在 cookies 中使用加密的签名。这意味着用户可以查看 cookie 的内容，
但是不能修改它，除非它知道签名的密钥。</p>
<p>要使用会话，你需要设置一个密钥。这里介绍会话如何工作:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">request</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">&#39;username&#39;</span> <span class="ow">in</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;Logged in as </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">escape</span><span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="s1">&#39;You are not logged in&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">session</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span>
<span class="s1">            &lt;p&gt;&lt;input type=text name=username&gt;</span>
<span class="s1">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span>
<span class="s1">        &lt;/form&gt;</span>
<span class="s1">    &#39;&#39;&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/logout&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="c1"># remove the username from the session if it&#39;s there</span>
    <span class="n">session</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>

<span class="c1"># set the secret key.  keep this really secret:</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="s1">&#39;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&#39;</span>
</pre></div>
</div>
<p>这里提到的 <a class="reference internal" href="api.html#flask.escape" title="flask.escape"><code class="xref py py-func docutils literal"><span class="pre">escape()</span></code></a> 可以在你不使用模板引擎的时候做转义（如同本例）。</p>
<div class="admonition- admonition">
<p class="first admonition-title">怎样产生一个好的密钥</p>
<p>随机的问题在于很难判断什么是真随机。一个密钥应该足够随机。你的操作系统可以基于一个密码随机生成器来生成漂亮的随机值，这个值可以用来做密钥:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="go">&#39;\xfd{H\xe5&lt;\x95\xf9\xe3\x96.5\xd1\x01O&lt;!\xd5\xa2\xa0\x9fR&quot;\xa1\xa8&#39;</span>
</pre></div>
</div>
<p class="last">把这个值复制粘贴到你的代码，你就搞定了密钥。</p>
</div>
<p>使用基于 cookie 的会话需注意: Flask 会将你放进会话对象的值序列化到 cookie。如果你试图寻找一个跨请求不能存留的值，
cookies 确实是启用的，并且你不会获得明确的错误信息，检查你页面请求中 cookie 的大小，并与 web 浏览器所支持的大小对比。</p>
</div>
<div class="section" id="id17">
<h2>消息闪烁<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<p>好的应用和用户界面全部是关于反馈。如果用户得不到足够的反馈，他们可能会变得讨厌这个应用。Flask 提供了一个
真正的简单的方式来通过消息闪现系统给用户反馈。消息闪现系统基本上使得在请求结束时记录信息并在下一个
（且仅在下一个）请求中访问。通常结合模板布局来显示消息。</p>
<p>使用 <a class="reference internal" href="api.html#flask.flash" title="flask.flash"><code class="xref py py-func docutils literal"><span class="pre">flash()</span></code></a> 方法来闪现一个消息，使用 <a class="reference internal" href="api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><code class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></code></a> 能够获取消息，
<a class="reference internal" href="api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><code class="xref py py-func docutils literal"><span class="pre">get_flashed_messages()</span></code></a> 也能用于模版中。针对一个完整的例子请查阅 <a class="reference internal" href="patterns/flashing.html#message-flashing-pattern"><span class="std std-ref">消息闪现</span></a>。</p>
</div>
<div class="section" id="id18">
<h2>日志<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.3.</span></p>
</div>
<p>有时候你会处于一种你处理的数据应该是正确的，然而实际上并不正确的状况。比如你可能有一些客户端代码，
代码向服务器发送一个 HTTP 请求但是显然它是畸形的。这可能是由于用户篡改数据，或客户端代码失败。
大部分时候针对这一情况返回 <code class="docutils literal"><span class="pre">400</span> <span class="pre">Bad</span> <span class="pre">Request</span></code> 就可以了，但是有时候不行因为代码必须继续工作。</p>
<p>你可能仍然想要记录发生什么不正常事情。这时候日志就派上用处。从 Flask 0.3 开始日志记录是预先配置好的。</p>
<p>这里有一些日志调用的例子:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;A value for debugging&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;A warning occurred (</span><span class="si">%d</span><span class="s1"> apples)&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;An error occurred&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>附带的 <a class="reference internal" href="api.html#flask.Flask.logger" title="flask.Flask.logger"><code class="xref py py-attr docutils literal"><span class="pre">logger</span></code></a> 是一个标准的日志类 <a class="reference external" href="https://docs.python.org/3/library/logging.html#logging.Logger" title="(in Python v3.6)"><code class="xref py py-class docutils literal"><span class="pre">Logger</span></code></a> ，因此更多的信息请
查阅官方文档 <a class="reference external" href="http://docs.python.org/library/logging.html">logging
documentation</a>。</p>
</div>
<div class="section" id="wsgi">
<h2>整合 WSGI 中间件<a class="headerlink" href="#wsgi" title="Permalink to this headline">¶</a></h2>
<p>如果你想给你的应用添加 WSGI 中间件，你可以封装内部 WSGI 应用。例如如果你想使用 Werkzeug 包中的某个中间件来应付 lighttpd 中的 bugs，你可以这样做:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">werkzeug.contrib.fixers</span> <span class="k">import</span> <span class="n">LighttpdCGIRootFix</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">LighttpdCGIRootFix</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="web">
<span id="quickstart-deployment"></span><h2>部署到 Web 服务器<a class="headerlink" href="#web" title="Permalink to this headline">¶</a></h2>
<p>准备好部署你的新 Flask 应用？你可以立即部署到托管平台来完成快速入门，以下是向小项目提供免费的方案:</p>
<ul class="simple">
<li><a class="reference external" href="http://devcenter.heroku.com/articles/python">Deploying Flask on Heroku</a></li>
<li><a class="reference external" href="http://docs.dotcloud.com/services/python/">Deploying WSGI on dotCloud</a>
with <a class="reference external" href="http://flask.pocoo.org/snippets/48/">Flask-specific notes</a></li>
</ul>
<p>你可以托管 Flask 应用的其它选择：</p>
<ul class="simple">
<li><a class="reference external" href="http://flask.pocoo.org/snippets/65/">Deploying Flask on Webfaction</a></li>
<li><a class="reference external" href="https://github.com/kamalgill/flask-appengine-template">Deploying Flask on Google App Engine</a></li>
<li><a class="reference external" href="http://flask.pocoo.org/snippets/89/">Sharing your Localhost Server with Localtunnel</a></li>
</ul>
<p>如果你管理你自己的主机并且想要自己运行，请参看 <a class="reference internal" href="deploying/index.html#deployment"><span class="std std-ref">部署方式</span></a>。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="index.html">
  <img class="logo" src="_static/flask.png" alt="Logo"/>
</a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">快速入门</a><ul>
<li><a class="reference internal" href="#id2">一个最小的应用</a></li>
<li><a class="reference internal" href="#debug-mode">调试模式</a></li>
<li><a class="reference internal" href="#id4">路由</a><ul>
<li><a class="reference internal" href="#id5">变量规则</a></li>
<li><a class="reference internal" href="#url">构建 URL</a></li>
<li><a class="reference internal" href="#http">HTTP方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">静态文件</a></li>
<li><a class="reference internal" href="#id7">渲染模板</a></li>
<li><a class="reference internal" href="#id10">接收请求数据</a><ul>
<li><a class="reference internal" href="#context-locals">局部上下文</a></li>
<li><a class="reference internal" href="#id12">请求对象</a></li>
<li><a class="reference internal" href="#id13">文件上传</a></li>
<li><a class="reference internal" href="#cookies">Cookies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id14">重定向和错误</a></li>
<li><a class="reference internal" href="#about-responses">关于响应</a></li>
<li><a class="reference internal" href="#sessions">会话</a></li>
<li><a class="reference internal" href="#id17">消息闪烁</a></li>
<li><a class="reference internal" href="#id18">日志</a></li>
<li><a class="reference internal" href="#wsgi">整合 WSGI 中间件</a></li>
<li><a class="reference internal" href="#web">部署到 Web 服务器</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="installation.html" title="previous chapter">安装</a></li>
      <li>Next: <a href="tutorial/index.html" title="next chapter">教程</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/quickstart.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2010 - 2018, Armin Ronacher.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/quickstart.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>